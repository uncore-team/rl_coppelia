from __future__ import annotations
import os
import textwrap
import re


def _snake_to_camel(name: str) -> str:
    """Convert snake/kebab to CamelCase."""
    parts = [p for p in re.split(r"[_\- ]+", name) if p]
    return "".join(s.capitalize() for s in parts)

def generate_env_code(robot_name: str, obs_vars: list, include_time: bool) -> str:
    """Build the Python source for the new Env class.

    Args:
        robot_name: Robot name (e.g., "burgerBot").
        obs_vars: List of dicts: [{"name": str, "low": float, "high": float}, ...]
        include_time: If True, append a 'time' observation with [0, 100] (you can adjust).

    Returns:
        Python file content as a string.
    """
    class_name = f"{_snake_to_camel(robot_name)}Env"

    # Build low/high arrays
    lows = [v["low"] for v in obs_vars]
    highs = [v["high"] for v in obs_vars]
    names = [v["name"] for v in obs_vars]

    # If include_time is selected, append a standard time dim
    # (matches your BurgerBotEnv style)
    if include_time:
        names.append("time_elapsed")
        lows.append(0.0)
        highs.append(100.0)

    # String format arrays
    low_arr = ", ".join(f"{x:.10g}" for x in lows)
    high_arr = ", ".join(f"{x:.10g}" for x in highs)
    names_list = ", ".join(repr(n) for n in names)

    return textwrap.dedent(f'''\
        """Auto-generated environment for '{robot_name}'.

        This Env inherits from CoppeliaEnv and defines a Box observation space based on GUI input.
        """

        import math
        import numpy as np
        import gymnasium as gym
        from gymnasium import spaces

        from common.coppelia_envs import CoppeliaEnv

        class {class_name}(CoppeliaEnv):
            def __init__(self, params_env, comms_port=49054):
                """Custom environment for '{robot_name}'.

                Args:
                    params_env (dict): Environment parameters.
                    comms_port (int, optional): Port for communication with the agent. Defaults to 49054.

                Notes:
                    The observation space is a Box with the variables specified at creation time:
                    names = [{names_list}]
                """
                super({class_name}, self).__init__(params_env, comms_port)

                # Define observation space
                self.observation_space = spaces.Box(
                    low=np.array([{low_arr}], dtype=np.float32),
                    high=np.array([{high_arr}], dtype=np.float32),
                    dtype=np.float32
                )

            # TODO: Implement other environment-specific methods if needed,
            # such as _get_observation(), _compute_reward(), step(), reset(), etc.
    ''')


def generate_plugin_code(robot_name: str) -> str:
    """Build the plugin source that registers the factory for this robot.

    Args:
        robot_name: Robot name.

    Returns:
        Python file content as a string.
    """
    class_name = f"{_snake_to_camel(robot_name)}Env"
    return textwrap.dedent(f'''\
        """Plugin to register '{robot_name}' robot environment.

        This module is auto-generated by the GUI. It registers a factory that builds
        a VecEnv for the robot using the manager's parameters.
        """

        from common.rl_coppelia_manager import RLCoppeliaManager
        from stable_baselines3.common.env_util import make_vec_env
        from robots.{robot_name}.envs import {class_name}

        def _factory(manager: RLCoppeliaManager):
            """Create a VecEnv instance for '{robot_name}'.

            Args:
                manager: The current RLCoppeliaManager instance.

            Returns:
                A vectorized environment (VecEnv) suitable for training/testing.
            """
            return make_vec_env(
                {class_name},
                n_envs=1,
                monitor_dir=manager.log_monitor,
                env_kwargs={{
                    "params_env": manager.params_env,
                    "comms_port": manager.free_comms_port,
                }},
            )

        # Register on module import
        RLCoppeliaManager.register_robot("{robot_name}", _factory)
    ''')


def create_robot_env_and_plugin(base_path: str, robot_name: str, spec: dict) -> tuple[str, str]:
    """Create the env module and the plugin for a new robot.

    Args:
        base_path: Project root (the parent of 'robots' and 'src').
        robot_name: New robot name (folder-friendly, e.g., 'myNewBot').
        spec: Dict as returned by NewEnvDialog.get_spec():
              {{
                "include_time": bool,
                "vars": [{{"name": str, "low": float, "high": float}}, ...]
              }}

    Returns:
        (env_file_path, plugin_file_path)
    """
    os.makedirs(os.path.join(base_path, "robots", robot_name), exist_ok=True)
    # robots/<robot>/__init__.py
    pkg_init = os.path.join(base_path, "robots", robot_name, "__init__.py")
    if not os.path.exists(pkg_init):
        with open(pkg_init, "w", encoding="utf-8") as f:
            f.write("# Package for robot: " + robot_name + "\n")

    # robots/<robot>/envs.py
    env_path = os.path.join(base_path, "robots", robot_name, "envs.py")
    env_src = generate_env_code(robot_name, spec["vars"], spec["include_time"])
    with open(env_path, "w", encoding="utf-8") as f:
        f.write(env_src)

    # src/rl_coppelia/robot_plugins/__init__.py
    plugins_pkg = os.path.join(base_path, "src", "rl_coppelia", "robot_plugins")
    os.makedirs(plugins_pkg, exist_ok=True)
    init_plugins = os.path.join(plugins_pkg, "__init__.py")
    if not os.path.exists(init_plugins):
        with open(init_plugins, "w", encoding="utf-8") as f:
            f.write("# Robot plugins package\n")

    # src/rl_coppelia/robot_plugins/<robot>.py
    plugin_path = os.path.join(plugins_pkg, f"{robot_name}.py")
    plugin_src = generate_plugin_code(robot_name)
    with open(plugin_path, "w", encoding="utf-8") as f:
        f.write(plugin_src)

    return env_path, plugin_path